---
title: Streaming SSR
description: Update head tags dynamically during Vue streaming server-side rendering
navigation.title: Streaming SSR
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming SSR sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With Vue's `renderToWebStream()`{lang="ts"} and Unhead's streaming support, you can:

- Update the document title as components load
- Add meta tags progressively
- Modify HTML/body attributes during streaming
- Deduplicate tags to prevent conflicts

## Basic Usage

```ts
import { createHead, streamAppWithUnhead } from '@unhead/vue/server'
import { renderToWebStream } from 'vue/server-renderer'

// Create a head instance per request
const head = createHead()

// Your Vue app stream
const appStream = renderToWebStream(app)

// Stream with head management
const htmlStart = '<!DOCTYPE html><html><head></head><body>'
const htmlEnd = '</body></html>'

for await (const chunk of streamAppWithUnhead(appStream, htmlStart, htmlEnd, head)) {
  res.write(chunk)
}
res.end()
```

## Suspense Integration

### HeadStream Component

Create a component that renders a stream marker. Unhead replaces this marker with JavaScript that updates head tags.

```vue
<!-- components/HeadStream.vue -->
<script lang="ts">
import { h } from 'vue'

export default {
  setup() {
    return () => h('script', {
      'data-unhead-stream': true,
      innerHTML: '<!--[unhead-stream]-->',
    })
  }
}
</script>
```

### Async Components

Use `useServerHead()`{lang="ts"} in async components to update head tags when they resolve:

```vue
<!-- components/ProductDetails.vue -->
<script setup>
import HeadStream from './HeadStream.vue'

const product = await fetchProduct()

useServerHead({
  title: product.name,
  meta: [
    { name: 'description', content: product.description },
    { property: 'og:title', content: product.name },
    { property: 'og:image', content: product.image }
  ]
})
</script>

<template>
  <div>
    <h1>{{ product.name }}</h1>
    <p>{{ product.description }}</p>
    <HeadStream />
  </div>
</template>
```

### App with Suspense

```vue
<!-- App.vue -->
<script setup>
import ProductDetails from './components/ProductDetails.vue'

useHead({
  title: 'Loading...',
  htmlAttrs: { lang: 'en' }
})
</script>

<template>
  <Suspense>
    <ProductDetails />
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>
```

## Bot Detection

Bots may not execute JavaScript for head updates. Serve complete HTML to crawlers:

```ts
import { createHead, renderSSRHead, streamAppWithUnhead } from '@unhead/vue/server'
import { isbot } from 'isbot'
import { renderToWebStream, renderToString } from 'vue/server-renderer'

export async function handleRequest(req, res) {
  const head = createHead()
  const app = createApp()
  app.use(head)

  const isBot = isbot(req.headers['user-agent'] || '')

  if (isBot) {
    // Complete HTML for bots
    const appHTML = await renderToString(app)
    const { headTags, bodyTags, htmlAttrs, bodyAttrs } = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${htmlAttrs}>
<head>${headTags}</head>
<body ${bodyAttrs}>${appHTML}${bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const appStream = renderToWebStream(app)
    res.set('Content-Type', 'text/html')
    for await (const chunk of streamAppWithUnhead(appStream, '<html><head></head><body>', '</body></html>', head)) {
      res.write(chunk)
    }
    res.end()
  }
}
```

## How It Works

1. **Initial Chunk**: Unhead injects initial head tags into the `<head>`{lang="html"} section
2. **Stream Markers**: The `<!--[unhead-stream]-->`{lang="html"} marker is replaced with JavaScript to update head tags
3. **Progressive Updates**: As components resolve, head updates are applied client-side
4. **Deduplication**: Tags with the same key are deduplicated to prevent conflicts

## Caveats

::warning
Keep these limitations in mind:

- Create a new head instance per request to avoid state contamination
- Body position scripts (`bodyOpen`{lang="ts"}, `bodyClose`{lang="ts"}) only appear in final output
- Stream markers split across chunks won't be processed
- Requires client-side JavaScript for progressive head updates
::

## API Reference

### streamAppWithUnhead

```ts
function streamAppWithUnhead(
  appStream: AsyncIterable<Uint8Array | string>,
  htmlStart: string,
  htmlEnd: string,
  head: Unhead
): AsyncGenerator<string>
```

Streams an SSR application with dynamic head management.

| Parameter | Description |
|-----------|-------------|
| `appStream` | The app's render stream |
| `htmlStart` | Initial HTML including `<html>`{lang="html"}, `<head>`{lang="html"}, and opening `<body>`{lang="html"} |
| `htmlEnd` | Closing HTML including `</body>`{lang="html"} and `</html>`{lang="html"} |
| `head` | The Unhead instance for this request |

### renderSSRStreamComponents

```ts
function renderSSRStreamComponents(
  head: Unhead,
  html: string
): Promise<string>
```

Processes a single HTML chunk for head updates. Used internally by `streamAppWithUnhead()`{lang="ts"}.

| Parameter | Description |
|-----------|-------------|
| `head` | The Unhead instance |
| `html` | HTML chunk to process |
