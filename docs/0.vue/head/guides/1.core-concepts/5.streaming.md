---
title: Streaming
description: Update head tags dynamically during Vue streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With Vue's `renderToWebStream()`{lang="ts"} and Unhead's streaming support, you can:

- Update the document title as async components load
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script that creates a queue on `window.__unhead__`{lang="ts"}
2. **Suspense chunks**: As async components resolve, head entries are serialized and sent via inline `<script>`{lang="html"} tags that push to the queue
3. **Client hydration**: The client head instance consumes the queue and takes over future updates

The system sends raw inputs (what you pass to `useHead()`{lang="ts"}) rather than resolved tags. This keeps payloads small and lets the client handle resolution the same way it would for any other head update.

## Vite Plugin Setup

Enable streaming mode in the Vite plugin - it will automatically inject head update scripts into components that use `useHead`:

```ts
import { unheadVuePlugin } from '@unhead/vue/stream/vite'
// vite.config.ts
import vue from '@vitejs/plugin-vue'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    vue(),
    unheadVuePlugin({ streaming: true }),
  ],
})
```

The plugin provides `virtual:@unhead/streaming-client`{lang="ts"} which is automatically injected by `streamWithHead`{lang="ts"}.

## Server Setup

```ts
import { createStreamableHead, streamWithHead } from '@unhead/vue/server'
import { renderToWebStream } from 'vue/server-renderer'

// Use createStreamableHead for streaming SSR
const head = createStreamableHead()
const app = createApp()
app.use(head)

const template = `<!DOCTYPE html>
<html>
<head></head>
<body><!--app-html--></body>
</html>`

const appStream = renderToWebStream(app)

res.set('Content-Type', 'text/html')
for await (const chunk of streamWithHead(appStream, template, head)) {
  res.write(chunk)
}
res.end()
```

## Component Usage

With the Vite plugin's `streaming: true` option, just use `useHead` normally - head updates are automatically streamed:

```vue
<!-- components/ProductDetails.vue -->
<script setup>
const product = await fetchProduct()

useHead({
  title: product.name,
  meta: [
    { name: 'description', content: product.description },
    { property: 'og:image', content: product.image }
  ]
})
</script>

<template>
  <div>
    <h1>{{ product.name }}</h1>
  </div>
</template>
```

### App with Suspense

```vue
<!-- App.vue -->
<script setup>
import ProductDetails from './components/ProductDetails.vue'

useHead({
  title: 'Loading...',
  htmlAttrs: { lang: 'en' }
})
</script>

<template>
  <Suspense>
    <ProductDetails />
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>
```

## Manual Integration

If you prefer not to use the Vite plugin, you can manually use the `HeadStream`{lang="ts"} component:

```vue
<script setup>
import { HeadStream } from '@unhead/vue/server'
import ProductDetails from './components/ProductDetails.vue'

useHead({
  title: 'Loading...',
  htmlAttrs: { lang: 'en' }
})
</script>

<template>
  <Suspense>
    <ProductDetails />
    <HeadStream />
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>
```

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} which automatically processes queued entries from streaming:

```ts
// entry-client.ts
import { createStreamableHead } from '@unhead/vue/client'

const head = createStreamableHead()
app.use(head)
```

This automatically:
- Processes any queued head entries from streaming
- Replaces the queue with direct head pushes
- Ensures no entries are lost regardless of when client JS loads

## Low-Level API

For more control, use the primitives directly:

```ts
import {
  renderSSRHeadShell,
  renderSSRHeadSuspenseChunk
} from '@unhead/vue/server'

// 1. Render shell with initial head
const shell = await renderSSRHeadShell(head, htmlStart)
res.write(shell)

// 2. Stream app content...
for await (const chunk of appStream) {
  res.write(chunk)

  // When a suspense boundary resolves:
  const headUpdate = renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

// 3. Close the response
res.write(htmlEnd)
```

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```ts
import {
  createHead,
  createStreamableHead,
  renderSSRHead,
  streamWithHead
} from '@unhead/vue/server'
import { isbot } from 'isbot'
import { renderToString, renderToWebStream } from 'vue/server-renderer'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  // Use createStreamableHead for streaming, createHead for bots
  const head = isBot ? createHead() : createStreamableHead()
  const app = createApp()
  app.use(head)

  if (isBot) {
    // Complete HTML for bots
    const html = await renderToString(app)
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}>${html}${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><!--app-html--></body></html>'
    res.set('Content-Type', 'text/html')
    for await (const chunk of streamWithHead(renderToWebStream(app), template, head)) {
      res.write(chunk)
    }
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
- Non-serializable values (functions, reactive refs, Promises) cannot be streamed
::

## API Reference

### createStreamableHead

```ts
// Server
import { createStreamableHead } from '@unhead/vue/server'

// Client
import { createStreamableHead } from '@unhead/vue/client'

function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): Unhead
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

### streamWithHead

```ts
function streamWithHead(
  appStream: AsyncIterable<Uint8Array | string>,
  template: string,
  head: Unhead
): AsyncGenerator<string>
```

Convenience wrapper that handles shell, suspense chunks, and closing.

| Parameter | Description |
|-----------|-------------|
| `appStream` | Vue's render stream |
| `template` | HTML template with `<!--app-html-->`{lang="html"} placeholder |
| `head` | The Unhead instance |

### renderSSRHeadShell

```ts
function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script. Clears entries after rendering.

### renderSSRHeadSuspenseChunk

```ts
function renderSSRHeadSuspenseChunk(head: Unhead): string
```

Returns JS to push new head entries to client queue. Clears entries after rendering.

### HeadStream

```ts
import { HeadStream } from '@unhead/vue/server'
```

Component that outputs head updates during streaming. Place after async components within suspense boundaries.
