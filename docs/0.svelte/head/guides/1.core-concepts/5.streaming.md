---
title: Streaming
description: Update head tags dynamically during Svelte streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With SvelteKit's streaming or custom SSR setups and Unhead's streaming support, you can:

- Update the document title as async data loads
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script that creates a queue on `window.__unhead__`{lang="ts"}
2. **Await chunks**: As `{#await}`{lang="svelte"} blocks resolve, `HeadStream`{lang="ts"} (auto-injected by the Vite plugin) outputs inline `<script>`{lang="html"} tags that push head entries to the queue
3. **Client hydration**: The client head instance consumes the queue and takes over future updates

The system sends raw inputs (what you pass to `useHead()`{lang="ts"}) rather than resolved tags. This keeps payloads small and lets the client handle resolution the same way it would for any other head update.

## Vite Plugin Setup

Enable streaming mode in the Vite plugin:

```ts
// vite.config.ts
import { sveltekit } from '@sveltejs/kit/vite'
import { unheadSveltePlugin } from '@unhead/svelte/stream/vite'

export default {
  plugins: [
    sveltekit(),
    unheadSveltePlugin({ streaming: true }),
  ],
}
```

The plugin handles everything automatically:
- Provides `virtual:@unhead/streaming-client`{lang="ts"} for early client-side queue processing
- **Auto-injects `HeadStream`{lang="ts"}** into templates that use `useHead`{lang="ts"}
- Transforms `index.html`{lang="html"} to include the bootstrap script

You only need to set up the shell rendering on your server - the plugin handles the await chunk streaming for you.

## Server Setup

With the Vite plugin, you only need to render the shell. The plugin auto-injects `HeadStream`{lang="ts"} that handles streaming head updates:

```ts
import { createStreamableHead, renderSSRHeadShell } from '@unhead/svelte/stream/server'

// Use createStreamableHead for streaming SSR
const head = createStreamableHead()

const template = `<!DOCTYPE html>
<html>
<head></head>
<body><!--app-html--></body>
</html>`

const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

res.set('Content-Type', 'text/html')

// 1. Render shell with initial head tags and bootstrap script
res.write(await renderSSRHeadShell(head, htmlStart))

// 2. Stream Svelte content (HeadStream is auto-injected by Vite plugin)
const svelteStream = renderApp()
for await (const chunk of svelteStream) {
  res.write(chunk)
}

// 3. Close the response
res.write(htmlEnd)
res.end()
```

That's it! The Vite plugin injects `HeadStream`{lang="ts"} into your templates, which emit head updates as await blocks resolve.

## Component Usage

Just use `useHead` normally - head updates are automatically streamed:

```svelte
<!-- components/ProductDetails.svelte -->
<script>
import { useHead } from '@unhead/svelte'

export let productPromise

async function loadProduct() {
  const product = await productPromise

  useHead({
    title: product.name,
    meta: [
      { name: 'description', content: product.description },
      { property: 'og:image', content: product.image }
    ]
  })

  return product
}
</script>

{#await loadProduct()}
  <p>Loading...</p>
{:then product}
  <div>
    <h1>{product.name}</h1>
    <p>{product.description}</p>
  </div>
{/await}
```

### App with Streaming

```svelte
<!-- +page.svelte -->
<script>
import { useHead } from '@unhead/svelte'
import ProductDetails from './ProductDetails.svelte'

useHead({
  title: 'Loading...',
  htmlAttrs: { lang: 'en' }
})

const productPromise = fetch('/api/product').then(r => r.json())
</script>

<ProductDetails {productPromise} />
```

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} which automatically processes queued entries from streaming:

```ts
// entry-client.ts
import { createStreamableHead } from '@unhead/svelte/stream/client'

const head = createStreamableHead()
// Use head with your app context
```

This automatically:
- Checks for an existing head instance (from the virtual module) and adopts it
- Processes any queued head entries from streaming
- Replaces the queue with direct head pushes
- Ensures no entries are lost regardless of when client JS loads

## Manual Integration (Without Vite Plugin)

If you're not using the Vite plugin, you need to:
1. Manually render await chunks on the server
2. Manually add `HeadStream`{lang="ts"} to your templates

### Server (Manual)

```ts
import { createStreamableHead, renderSSRHeadShell, renderSSRHeadSuspenseChunk } from '@unhead/svelte/stream/server'

const head = createStreamableHead()

const template = '<html><head></head><body><!--app-html--></body></html>'
const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

res.write(await renderSSRHeadShell(head, htmlStart))

const svelteStream = renderApp()
for await (const chunk of svelteStream) {
  res.write(chunk)

  // Manually emit head updates after each chunk
  const headUpdate = renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

res.write(htmlEnd)
res.end()
```

### Template (Manual)

Use `HeadStream`{lang="ts"} with `{@html}`{lang="svelte"} after async blocks:

```svelte
<script>
import { HeadStream } from '@unhead/svelte/stream/server'
</script>

{@html HeadStream()}
```

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```ts
import { createHead, renderSSRHead } from '@unhead/svelte/server'
import { createStreamableHead, renderSSRHeadShell } from '@unhead/svelte/stream/server'
import { isbot } from 'isbot'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  const head = isBot ? createHead() : createStreamableHead()

  if (isBot) {
    // Complete HTML for bots
    const html = await renderToString(app)
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}>${html}${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><!--app-html--></body></html>'
    const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

    res.set('Content-Type', 'text/html')
    res.write(await renderSSRHeadShell(head, htmlStart))

    // Vite plugin auto-injects HeadStream - just stream the content
    const svelteStream = renderApp()
    for await (const chunk of svelteStream) {
      res.write(chunk)
    }

    res.write(htmlEnd)
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
- Non-serializable values (functions, Promises) cannot be streamed
::

## API Reference

### createStreamableHead

```ts
// Client
import { createStreamableHead } from '@unhead/svelte/stream/client'

// Server
import { createStreamableHead } from '@unhead/svelte/stream/server'

function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): Unhead
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

### renderSSRHeadShell

```ts
import { renderSSRHeadShell } from '@unhead/svelte/stream/server'

function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script. Clears entries after rendering.

The bootstrap script creates: `window.__unhead__ = { _q: [], push(e) { this._q.push(e) } }`{lang="ts"}

### renderSSRHeadSuspenseChunk

```ts
import { renderSSRHeadSuspenseChunk } from '@unhead/svelte/stream/server'

function renderSSRHeadSuspenseChunk(head: Unhead): string
```

Returns JS to push new head entries to client queue. Clears entries after rendering. Returns empty string if no new entries.

Only needed for manual integration without the Vite plugin.

### HeadStream

```ts
import { HeadStream } from '@unhead/svelte/stream/server'

function HeadStream(): string
```

Returns a script tag string for head updates during streaming. The Vite plugin auto-injects this - you only need it for manual integration.

Use with `{@html HeadStream()}`{lang="svelte"} in your templates.
