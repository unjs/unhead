---
title: Streaming
description: Update head tags dynamically during Svelte streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With SvelteKit's streaming or custom SSR setups and Unhead's streaming support, you can:

- Update the document title as async data loads
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script that creates a queue on `window.__unhead__`{lang="ts"}
2. **Await chunks**: As async blocks resolve, head entries are serialized and sent via inline `<script>`{lang="html"} tags that push to the queue
3. **Client hydration**: The client head instance consumes the queue and takes over future updates

The system sends raw inputs (what you pass to `useHead()`{lang="ts"}) rather than resolved tags. This keeps payloads small and lets the client handle resolution the same way it would for any other head update.

## Vite Plugin Setup

Enable streaming mode in the Vite plugin - it will automatically inject head update scripts into components that use `useHead`:

```ts
// vite.config.ts
import { sveltekit } from '@sveltejs/kit/vite'
import { unheadSveltePlugin } from '@unhead/svelte/stream/vite'

export default {
  plugins: [
    sveltekit(),
    unheadSveltePlugin({ streaming: true }),
  ],
}
```

The plugin provides `virtual:@unhead/streaming-client`{lang="ts"} which is automatically injected by `streamWithHead`{lang="ts"}.

## Server Setup

```ts
import { createStreamableHead, streamWithHead } from '@unhead/svelte/server'

// Use createStreamableHead for streaming SSR
const head = createStreamableHead()

const template = `<!DOCTYPE html>
<html>
<head></head>
<body><!--app-html--></body>
</html>`

// Your app stream from SvelteKit or custom SSR
const appStream = renderApp()

res.set('Content-Type', 'text/html')
for await (const chunk of streamWithHead(appStream, template, head)) {
  res.write(chunk)
}
res.end()
```

## Component Usage

With the Vite plugin's `streaming: true` option, just use `useHead` normally - head updates are automatically streamed:

```svelte
<!-- components/ProductDetails.svelte -->
<script>
import { useHead } from '@unhead/svelte'

export let productPromise

async function loadProduct() {
  const product = await productPromise

  useHead({
    title: product.name,
    meta: [
      { name: 'description', content: product.description },
      { property: 'og:image', content: product.image }
    ]
  })

  return product
}
</script>

{#await loadProduct()}
  <p>Loading...</p>
{:then product}
  <div>
    <h1>{product.name}</h1>
    <p>{product.description}</p>
  </div>
{/await}
```

### App with Streaming

```svelte
<!-- +page.svelte -->
<script>
import { useHead } from '@unhead/svelte'
import ProductDetails from './ProductDetails.svelte'

useHead({
  title: 'Loading...',
  htmlAttrs: { lang: 'en' }
})

const productPromise = fetch('/api/product').then(r => r.json())
</script>

<ProductDetails {productPromise} />
```

## Manual Integration

If you prefer not to use the Vite plugin, use the `HeadStream`{lang="ts"} function:

```svelte
<script>
import { HeadStream } from '@unhead/svelte/server'
</script>

{@html HeadStream()}
```

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} which automatically processes queued entries from streaming:

```ts
// entry-client.ts
import { createStreamableHead } from '@unhead/svelte/client'

const head = createStreamableHead()
// Use head with your app context
```

This automatically:
- Processes any queued head entries from streaming
- Replaces the queue with direct head pushes
- Ensures no entries are lost regardless of when client JS loads

## Low-Level API

For more control, use the primitives directly:

```ts
import {
  renderSSRHeadShell,
  renderSSRHeadSuspenseChunk
} from '@unhead/svelte/server'

// 1. Render shell with initial head
const shell = await renderSSRHeadShell(head, htmlStart)
res.write(shell)

// 2. Stream app content...
for await (const chunk of appStream) {
  res.write(chunk)

  // When an await block resolves:
  const headUpdate = renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

// 3. Close the response
res.write(htmlEnd)
```

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```ts
import {
  createHead,
  createStreamableHead,
  renderSSRHead,
  streamWithHead
} from '@unhead/svelte/server'
import { isbot } from 'isbot'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  const head = isBot ? createHead() : createStreamableHead()

  if (isBot) {
    // Complete HTML for bots
    const html = await renderToString(app)
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}>${html}${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><!--app-html--></body></html>'
    res.set('Content-Type', 'text/html')
    for await (const chunk of streamWithHead(appStream, template, head)) {
      res.write(chunk)
    }
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
- Non-serializable values (functions, Promises) cannot be streamed
::

## API Reference

### createStreamableHead

```ts
// Client
import { createStreamableHead } from '@unhead/svelte/client'

// Server
import { createStreamableHead } from '@unhead/svelte/server'

function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): Unhead
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

### streamWithHead

```ts
function streamWithHead(
  appStream: AsyncIterable<Uint8Array | string>,
  template: string,
  head: Unhead
): AsyncGenerator<string>
```

Convenience wrapper that handles shell, await chunks, and closing.

| Parameter | Description |
|-----------|-------------|
| `appStream` | Svelte's render stream |
| `template` | HTML template with `<!--app-html-->`{lang="html"} placeholder |
| `head` | The Unhead instance |

### renderSSRHeadShell

```ts
function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script. Clears entries after rendering.

### renderSSRHeadSuspenseChunk

```ts
function renderSSRHeadSuspenseChunk(head: Unhead): string
```

Returns JS to push new head entries to client queue. Clears entries after rendering.

### HeadStream

```ts
import { HeadStream } from '@unhead/svelte/server'

function HeadStream(): string
```

Returns a script tag string for head updates during streaming. Use with `{@html HeadStream()}`{lang="svelte"}.
