---
title: Streaming
description: Update head tags dynamically during Svelte streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With SvelteKit's streaming or custom SSR setups and Unhead's streaming support, you can:

- Update the document title as async data loads
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script
2. **Await chunks**: Async blocks push serialized head updates to `window.__unhead__`{lang="ts"}
3. **Client hydration**: Unhead consumes the queue and manages DOM updates natively

## Basic Usage

```ts
import { createStreamableHead, streamWithHead } from '@unhead/svelte/server'

// Use createStreamableHead for streaming SSR
const head = createStreamableHead()

const template = `<!DOCTYPE html>
<html>
<head></head>
<body><!--app-html--></body>
</html>`

// Your app stream from SvelteKit or custom SSR
const appStream = renderApp()

res.set('Content-Type', 'text/html')
for await (const chunk of streamWithHead(appStream, template, head)) {
  res.write(chunk)
}
res.end()
```

## Await Block Integration

### HeadStream Function

Use `HeadStream()`{lang="ts"} in your `{#await}` blocks to emit head updates:

```svelte
<!-- components/ProductDetails.svelte -->
<script>
import { HeadStream } from '@unhead/svelte/server'
import { useHead } from '@unhead/svelte'

export let productPromise

async function loadProduct() {
  const product = await productPromise

  useHead({
    title: product.name,
    meta: [
      { name: 'description', content: product.description },
      { property: 'og:image', content: product.image }
    ]
  })

  return product
}
</script>

{#await loadProduct()}
  <p>Loading...</p>
{:then product}
  <div>
    <h1>{product.name}</h1>
    <p>{product.description}</p>
  </div>
  {@html HeadStream()}
{/await}
```

### Vite Plugin (Recommended)

Use the Vite plugin to automatically inject `HeadStream()` into `{#await}` blocks:

```ts
import { sveltekit } from '@sveltejs/kit/vite'
// vite.config.ts
import { unheadSveltePlugin } from '@unhead/svelte/vite-plugin'

export default {
  plugins: [
    sveltekit(),
    unheadSveltePlugin(),
  ],
}
```

With the plugin, you can write clean code without manual script injection:

```svelte
<!-- The plugin automatically adds {@html HeadStream()} -->
<script>
import { useHead } from '@unhead/svelte'

export let productPromise
</script>

{#await productPromise}
  <p>Loading...</p>
{:then product}
  <ProductView {product} />
{/await}
```

### App with Streaming

```svelte
<!-- +page.svelte -->
<script>
import { useHead } from '@unhead/svelte'
import ProductDetails from './ProductDetails.svelte'

useHead({
  title: 'Loading...',
  htmlAttrs: { lang: 'en' }
})

const productPromise = fetch('/api/product').then(r => r.json())
</script>

<ProductDetails {productPromise} />
```

## Low-Level API

For more control, use the primitives directly:

```ts
import {
  renderSSRHeadClosing,
  renderSSRHeadShell,
  renderSSRHeadSuspenseChunk
} from '@unhead/svelte/server'

// 1. Render shell with initial head
const shell = await renderSSRHeadShell(head, htmlStart)
res.write(shell)

// 2. Stream app content...
for await (const chunk of appStream) {
  res.write(chunk)

  // When an await block resolves:
  const headUpdate = await renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

// 3. Close with body tags
const closing = await renderSSRHeadClosing(head)
res.write(closing + htmlEnd)
```

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```ts
import {
  createHead,
  createStreamableHead,
  renderSSRHead,
  streamWithHead
} from '@unhead/svelte/server'
import { isbot } from 'isbot'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  const head = isBot ? createHead() : createStreamableHead()

  if (isBot) {
    // Complete HTML for bots
    const html = await renderToString(app)
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}>${html}${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><!--app-html--></body></html>'
    res.set('Content-Type', 'text/html')
    for await (const chunk of streamWithHead(appStream, template, head)) {
      res.write(chunk)
    }
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
::

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} to consume the streaming queue:

```ts
// entry-client.ts
import { createStreamableHead } from '@unhead/svelte/client'

const head = createStreamableHead()
// Use head with your app context
```

This automatically:
- Processes any queued head entries from streaming
- Replaces the queue with direct DOM updates

## API Reference

### createStreamableHead

```ts
// Client
import { createStreamableHead } from '@unhead/svelte/client'

// Server
import { createStreamableHead } from '@unhead/svelte/server'

function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): Unhead
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

### streamWithHead

```ts
function streamWithHead(
  appStream: AsyncIterable<Uint8Array | string>,
  template: string,
  head: Unhead
): AsyncGenerator<string>
```

Convenience wrapper that handles shell, await chunks, and closing.

| Parameter | Description |
|-----------|-------------|
| `appStream` | Svelte's render stream |
| `template` | HTML template with `<!--app-html-->`{lang="html"} placeholder |
| `head` | The Unhead instance |

### renderSSRHeadShell

```ts
function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script.

### renderSSRHeadSuspenseChunk

```ts
function renderSSRHeadSuspenseChunk(head: Unhead): Promise<string>
```

Returns JS to push new head entries to client queue.

### renderSSRHeadClosing

```ts
function renderSSRHeadClosing(head: Unhead): Promise<string>
```

Returns body-positioned tags for end of document.

### HeadStream

```ts
import { HeadStream } from '@unhead/svelte/server'

function HeadStream(): string
```

Returns a script tag string with head updates. Use with `{@html ...}` in `{#await}` blocks after async data resolves.
