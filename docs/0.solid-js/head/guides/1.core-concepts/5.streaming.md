---
title: Streaming
description: Update head tags dynamically during Solid streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With Solid's `renderToStream()`{lang="ts"} and Unhead's streaming support, you can:

- Update the document title as async components load
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script
2. **Suspense chunks**: Async components push serialized head updates to `window.__unhead__`{lang="ts"}
3. **Client hydration**: Unhead consumes the queue and manages DOM updates natively

## Basic Usage

```tsx
import { createStreamableHead, streamWithHead } from '@unhead/solid-js/server'
import { renderToStream } from 'solid-js/web'

// Use createStreamableHead for streaming SSR
const head = createStreamableHead()

const template = `<!DOCTYPE html>
<html>
<head></head>
<body><!--app-html--></body>
</html>`

const appStream = renderToStream(() => (
  <UnheadContext.Provider value={head}>
    <App />
  </UnheadContext.Provider>
))

res.set('Content-Type', 'text/html')
for await (const chunk of streamWithHead(appStream, template, head)) {
  res.write(chunk)
}
res.end()
```

## Suspense Integration

### HeadStream Component

Use the built-in `HeadStream`{lang="tsx"} component from `@unhead/solid-js/server`:

```tsx
import { HeadStream } from '@unhead/solid-js/server'

// Place after async components that use useHead
function ProductDetails(props) {
  const [product] = createResource(() => fetchProduct(props.id))

  createEffect(() => {
    if (product()) {
      useHead({
        title: product().name,
        meta: [{ name: 'description', content: product().description }]
      })
    }
  })

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Show when={product()}>
        <div>
          <h1>{product().name}</h1>
        </div>
      </Show>
      <HeadStream />
    </Suspense>
  )
}
```

### Vite Plugin (Recommended)

Use the Vite plugin to automatically inject `HeadStream` into `Suspense` boundaries:

```ts
// vite.config.ts
import { unheadSolidPlugin } from '@unhead/solid-js/vite-plugin'
import solid from 'vite-plugin-solid'

export default {
  plugins: [
    solid(),
    unheadSolidPlugin(),
  ],
}
```

With the plugin, you can write clean code without manual HeadStream placement:

```tsx
// The plugin automatically adds <HeadStream /> before </Suspense>
function ProductPage() {
  const [product] = createResource(() => fetchProduct())

  useHead(() => ({
    title: product()?.name ?? 'Loading...',
  }))

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ProductDetails product={product()} />
    </Suspense>
  )
}
```

### App with Suspense

```tsx
import { useHead } from '@unhead/solid-js'
import { HeadStream, UnheadContext } from '@unhead/solid-js/server'
// App.tsx
import { Suspense } from 'solid-js'
import { ProductDetails } from './components/ProductDetails'

export function App() {
  useHead({
    title: 'Loading...',
    htmlAttrs: { lang: 'en' }
  })

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ProductDetails />
      <HeadStream />
    </Suspense>
  )
}
```

## Low-Level API

For more control, use the primitives directly:

```ts
import {
  renderSSRHeadClosing,
  renderSSRHeadShell,
  renderSSRHeadSuspenseChunk
} from '@unhead/solid-js/server'

// 1. Render shell with initial head
const shell = await renderSSRHeadShell(head, htmlStart)
res.write(shell)

// 2. Stream app content...
for await (const chunk of appStream) {
  res.write(chunk)

  // When a suspense boundary resolves:
  const headUpdate = await renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

// 3. Close with body tags
const closing = await renderSSRHeadClosing(head)
res.write(closing + htmlEnd)
```

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```tsx
import { createHead, createStreamableHead, renderSSRHead, streamWithHead, UnheadContext } from '@unhead/solid-js/server'
import { isbot } from 'isbot'
import { renderToStream, renderToString } from 'solid-js/web'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  const head = isBot ? createHead() : createStreamableHead()

  const app = () => (
    <UnheadContext.Provider value={head}>
      <App />
    </UnheadContext.Provider>
  )

  if (isBot) {
    // Complete HTML for bots
    const html = await renderToString(app)
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}>${html}${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><!--app-html--></body></html>'
    const appStream = renderToStream(app)
    res.set('Content-Type', 'text/html')
    for await (const chunk of streamWithHead(appStream, template, head)) {
      res.write(chunk)
    }
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
::

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} to consume the streaming queue:

```tsx
// entry-client.tsx
import { UnheadContext } from '@unhead/solid-js'
import { createStreamableHead } from '@unhead/solid-js/client'
import { hydrate } from 'solid-js/web'

const head = createStreamableHead()

hydrate(
  () => (
    <UnheadContext.Provider value={head}>
      <App />
    </UnheadContext.Provider>
  ),
  document.getElementById('app')
)
```

This automatically:
- Processes any queued head entries from streaming
- Replaces the queue with direct DOM updates

## API Reference

### createStreamableHead

```ts
// Client
import { createStreamableHead } from '@unhead/solid-js/client'

// Server
import { createStreamableHead } from '@unhead/solid-js/server'

function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): Unhead
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

### streamWithHead

```ts
function streamWithHead(
  appStream: AsyncIterable<Uint8Array | string>,
  template: string,
  head: Unhead
): AsyncGenerator<string>
```

Convenience wrapper that handles shell, suspense chunks, and closing.

| Parameter | Description |
|-----------|-------------|
| `appStream` | Solid's render stream |
| `template` | HTML template with `<!--app-html-->`{lang="html"} placeholder |
| `head` | The Unhead instance |

### renderSSRHeadShell

```ts
function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script.

### renderSSRHeadSuspenseChunk

```ts
function renderSSRHeadSuspenseChunk(head: Unhead): Promise<string>
```

Returns JS to push new head entries to client queue.

### renderSSRHeadClosing

```ts
function renderSSRHeadClosing(head: Unhead): Promise<string>
```

Returns body-positioned tags for end of document.

### HeadStream

```tsx
import { HeadStream } from '@unhead/solid-js/server'

function HeadStream(): JSX.Element | null
```

Component that outputs head updates during streaming. Place after async components inside Suspense boundaries.
