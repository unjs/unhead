---
title: Streaming
description: Update head tags dynamically during React streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With React's `renderToPipeableStream()`{lang="ts"} or `renderToReadableStream()`{lang="ts"} and Unhead's streaming support, you can:

- Update the document title as async components load
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script that creates a queue on `window.__unhead__`{lang="ts"}
2. **Suspense chunks**: As async components resolve, `HeadStream`{lang="tsx"} components (auto-injected by the Vite plugin) output inline `<script>`{lang="html"} tags that push head entries to the queue
3. **Client hydration**: The client head instance consumes the queue and takes over future updates

The system sends raw inputs (what you pass to `useHead()`{lang="ts"}) rather than resolved tags. This keeps payloads small and lets the client handle resolution the same way it would for any other head update.

## Vite Plugin Setup

Enable streaming mode in the Vite plugin:

```ts
// vite.config.ts
import { unheadReactPlugin } from '@unhead/react/stream/vite'
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    react(),
    unheadReactPlugin(),
  ],
})
```

The plugin handles everything automatically:
- Provides `virtual:@unhead/streaming-client`{lang="ts"} for early client-side queue processing
- **Auto-injects `HeadStream`{lang="tsx"} components** into JSX that uses `useHead`{lang="ts"}
- Transforms `index.html`{lang="html"} to include the bootstrap script

You only need to set up the shell rendering on your server - the plugin handles the suspense chunk streaming for you.

## Server Setup

With the Vite plugin, you only need to render the shell. The plugin auto-injects `HeadStream`{lang="tsx"} components that handle streaming head updates.

### Using renderToPipeableStream (Recommended)

The `wrap()`{lang="ts"} helper handles shell rendering and template injection automatically:

```tsx
import { renderToPipeableStream } from 'react-dom/server'
import { StaticRouter } from 'react-router-dom/server'
import { createStreamableHead, UnheadProvider } from '@unhead/react/stream/server'

export function render(url: string, template: string) {
  const { head, onShellReady, wrap } = createStreamableHead()

  const { pipe, abort } = renderToPipeableStream(
    <UnheadProvider value={head}>
      <StaticRouter location={url}>
        <App />
      </StaticRouter>
    </UnheadProvider>,
    { onShellReady },
  )

  return {
    abort,
    pipe: wrap(pipe, template),
  }
}
```

Then in your server:

```js
app.use('*', async (req, res) => {
  const { pipe } = render(req.originalUrl, template)
  res.status(200).set({ 'Content-Type': 'text/html' })
  pipe(res)
})
```

The `wrap()`{lang="ts"} function:
1. Waits for `onShellReady`{lang="ts"} to fire
2. Renders the initial head tags and bootstrap script
3. Pipes React content through
4. Appends the closing HTML

### Using renderToReadableStream

For environments that prefer Web Streams:

```tsx
import { renderToReadableStream } from 'react-dom/server'
import { createStreamableHead, renderSSRHeadShell, UnheadProvider } from '@unhead/react/stream/server'

export async function render(url: string, template: string) {
  const { head } = createStreamableHead()

  const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

  const app = (
    <UnheadProvider value={head}>
      <App />
    </UnheadProvider>
  )

  // Render shell with initial head tags and bootstrap script
  const shell = await renderSSRHeadShell(head, htmlStart)

  // Stream React content
  const reactStream = await renderToReadableStream(app)

  return new ReadableStream({
    async start(controller) {
      controller.enqueue(new TextEncoder().encode(shell))
      for await (const chunk of reactStream) {
        controller.enqueue(chunk)
      }
      controller.enqueue(new TextEncoder().encode(htmlEnd))
      controller.close()
    }
  })
}
```

The Vite plugin injects `HeadStream`{lang="tsx"} components into your JSX, which emit head updates as suspense boundaries resolve.

## Component Usage

Just use `useHead` normally - head updates are automatically streamed:

```tsx
// components/ProductDetails.tsx
function ProductDetails({ productPromise }) {
  const product = use(productPromise)

  useHead({
    title: product.name,
    meta: [{ name: 'description', content: product.description }]
  })

  return (
    <div>
      <h1>{product.name}</h1>
    </div>
  )
}
```

### App with Suspense

```tsx
// App.tsx
import { useHead } from '@unhead/react'
import { Suspense } from 'react'
import { ProductDetails } from './components/ProductDetails'

export function App() {
  useHead({
    title: 'Loading...',
    htmlAttrs: { lang: 'en' }
  })

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ProductDetails productPromise={fetchProduct()} />
    </Suspense>
  )
}
```

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} which automatically processes queued entries from streaming:

```tsx
import { createStreamableHead, UnheadProvider } from '@unhead/react/stream/client'
// entry-client.tsx
import { hydrateRoot } from 'react-dom/client'

const head = createStreamableHead()

hydrateRoot(
  document.getElementById('app'),
  <UnheadProvider head={head}>
    <App />
  </UnheadProvider>
)
```

This automatically:
- Checks for an existing head instance (from the virtual module) and adopts it
- Processes any queued head entries from streaming
- Replaces the queue with direct head pushes
- Ensures no entries are lost regardless of when client JS loads

## Manual Integration (Without Vite Plugin)

If you're not using the Vite plugin, you need to:
1. Manually render suspense chunks on the server
2. Manually add `HeadStream`{lang="tsx"} components to your JSX

### Server (Manual)

```tsx
import { UnheadProvider } from '@unhead/react/server'
import { renderToReadableStream } from 'react-dom/server'
import { createStreamableHead, renderSSRHeadShell, renderSSRHeadSuspenseChunk } from '@unhead/react/stream/server'

const head = createStreamableHead()

const app = (
  <UnheadProvider value={head}>
    <App />
  </UnheadProvider>
)

const template = '<html><head></head><body><div id="app"><!--app-html--></div></body></html>'
const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

res.write(await renderSSRHeadShell(head, htmlStart))

const reactStream = await renderToReadableStream(app)
for await (const chunk of reactStream) {
  res.write(chunk)

  // Manually emit head updates after each chunk
  const headUpdate = renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

res.write(htmlEnd)
res.end()
```

### Component (Manual)

Place `HeadStream`{lang="tsx"} after async components within suspense boundaries:

```tsx
import { useHead } from '@unhead/react'
import { HeadStream } from '@unhead/react/stream/server'
import { Suspense } from 'react'
import { ProductDetails } from './components/ProductDetails'

export function App() {
  useHead({
    title: 'Loading...',
    htmlAttrs: { lang: 'en' }
  })

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ProductDetails productPromise={fetchProduct()} />
      <HeadStream />
    </Suspense>
  )
}
```

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```tsx
import { UnheadProvider } from '@unhead/react/server'
import { createHead, renderSSRHead } from '@unhead/react/server'
import { createStreamableHead, renderSSRHeadShell } from '@unhead/react/stream/server'
import { isbot } from 'isbot'
import { renderToReadableStream, renderToString } from 'react-dom/server'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  const head = isBot ? createHead() : createStreamableHead()

  const app = (
    <UnheadProvider value={head}>
      <App />
    </UnheadProvider>
  )

  if (isBot) {
    // Complete HTML for bots
    const html = await renderToString(app)
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}><div id="app">${html}</div>${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><div id="app"><!--app-html--></div></body></html>'
    const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

    res.set('Content-Type', 'text/html')
    res.write(await renderSSRHeadShell(head, htmlStart))

    // Vite plugin auto-injects HeadStream - just stream the content
    const reactStream = await renderToReadableStream(app)
    for await (const chunk of reactStream) {
      res.write(chunk)
    }

    res.write(htmlEnd)
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
- Non-serializable values (functions, Promises) cannot be streamed
::

## API Reference

### createStreamableHead

```ts
// Client
import { createStreamableHead } from '@unhead/react/stream/client'

// Server
import { createStreamableHead } from '@unhead/react/stream/server'

// Server returns ReactStreamableHeadContext
function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): {
  head: Unhead
  onShellReady: () => void
  wrap: (pipe: ReactPipeFunction, template: string) => (writable: Writable) => void
}
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

| Return | Description |
|--------|-------------|
| `head` | The Unhead instance to pass to `UnheadProvider` |
| `onShellReady` | Callback to pass to `renderToPipeableStream`'s options |
| `wrap` | Wraps React's `pipe` function to handle shell + template injection |

### renderSSRHeadShell

```ts
import { renderSSRHeadShell } from '@unhead/react/stream/server'

function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script. Clears entries after rendering.

The bootstrap script creates: `window.__unhead__ = { _q: [], push(e) { this._q.push(e) } }`{lang="ts"}

### renderSSRHeadSuspenseChunk

```ts
import { renderSSRHeadSuspenseChunk } from '@unhead/react/stream/server'

function renderSSRHeadSuspenseChunk(head: Unhead): string
```

Returns JS to push new head entries to client queue. Clears entries after rendering. Returns empty string if no new entries.

Only needed for manual integration without the Vite plugin.

### HeadStream

```tsx
import { HeadStream } from '@unhead/react/stream/server'

function HeadStream(): ReactNode
```

React component that outputs head updates during streaming. The Vite plugin auto-injects this - you only need it for manual integration.

Uses `renderSSRHeadSuspenseChunk`{lang="ts"} internally. Always renders a `<script>`{lang="html"} tag with `suppressHydrationWarning`{lang="ts"} for hydration consistency.
