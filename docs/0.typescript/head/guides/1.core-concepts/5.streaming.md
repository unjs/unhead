---
title: Streaming
description: Update head tags dynamically during streaming server-side rendering
navigation.title: Streaming
new: true
---

## Introduction

::warning
This API is experimental and may change in future versions.
::

Streaming sends HTML to the browser as it's ready, rather than waiting for the entire page to render. With Unhead's streaming support, you can:

- Update the document title as async content loads
- Add meta tags progressively
- Leverage Unhead's native client-side DOM management

## How It Works

Unhead uses a queue-based approach for streaming:

1. **Shell**: Initial `<head>`{lang="html"} is rendered with a bootstrap script that creates a queue on `window.__unhead__`{lang="ts"}
2. **Chunks**: As async content resolves, head entries are serialized and sent via inline `<script>`{lang="html"} tags that push to the queue
3. **Client hydration**: The client head instance consumes the queue and takes over future updates

The system sends raw inputs (what you pass to `head.push()`{lang="ts"}) rather than resolved tags. This keeps payloads small and lets the client handle resolution the same way it would for any other head update.

## Server Setup

The vanilla TypeScript API gives you full control over streaming. Use `renderSSRHeadShell`{lang="ts"} for the initial shell and `renderSSRHeadSuspenseChunk`{lang="ts"} for updates:

```ts
import {
  createStreamableHead,
  renderSSRHeadShell,
  renderSSRHeadSuspenseChunk
} from 'unhead/stream/server'

// Create streamable head instance for this request
const head = createStreamableHead()

// Add initial head entries
head.push({
  title: 'My App',
  htmlAttrs: { lang: 'en' }
})

const template = `<!DOCTYPE html>
<html>
<head></head>
<body><!--app-html--></body>
</html>`

const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

res.set('Content-Type', 'text/html')

// 1. Render shell with initial head tags and bootstrap script
res.write(await renderSSRHeadShell(head, htmlStart))

// 2. Stream your app content...
for await (const chunk of appStream) {
  res.write(chunk)

  // After async content resolves, emit head updates
  const headUpdate = renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}

// 3. Close the response
res.write(htmlEnd)
res.end()
```

## Streaming Pattern

For async content that adds head entries:

```ts
// Your async content handler
async function renderAsyncContent(head) {
  const data = await fetchData()

  // Push head entries for this content
  head.push({
    title: data.title,
    meta: [{ name: 'description', content: data.description }]
  })

  return renderContent(data)
}

// In your streaming loop
for await (const chunk of appStream) {
  res.write(chunk)

  // Emit any new head entries after each chunk
  const headUpdate = renderSSRHeadSuspenseChunk(head)
  if (headUpdate) {
    res.write(`<script>${headUpdate}</script>`)
  }
}
```

## Client Setup

On the client, use `createStreamableHead`{lang="ts"} to consume the streaming queue:

```ts
import { createStreamableHead } from 'unhead/stream/client'

const head = createStreamableHead()
```

This automatically:
- Checks for an existing head instance (from early script) and adopts it
- Processes any queued head entries from streaming
- Replaces the queue with direct head pushes
- Ensures no entries are lost regardless of when client JS loads

## Bot Detection

Bots may not execute JavaScript. Serve complete HTML to crawlers:

```ts
import { createHead, renderSSRHead } from 'unhead/server'
import { createStreamableHead, renderSSRHeadShell, renderSSRHeadSuspenseChunk } from 'unhead/stream/server'
import { isbot } from 'isbot'

export async function handleRequest(req, res) {
  const isBot = isbot(req.headers['user-agent'] || '')
  const head = isBot ? createHead() : createStreamableHead()

  // Add your head entries
  head.push({
    title: 'My App',
    htmlAttrs: { lang: 'en' }
  })

  if (isBot) {
    // Complete HTML for bots
    const html = await renderApp()
    const ssr = await renderSSRHead(head)
    res.send(`<!DOCTYPE html>
<html ${ssr.htmlAttrs}>
<head>${ssr.headTags}</head>
<body ${ssr.bodyAttrs}>${html}${ssr.bodyTags}</body>
</html>`)
  }
  else {
    // Streaming for users
    const template = '<html><head></head><body><!--app-html--></body></html>'
    const [htmlStart, htmlEnd] = template.split('<!--app-html-->')

    res.set('Content-Type', 'text/html')
    res.write(await renderSSRHeadShell(head, htmlStart))

    for await (const chunk of appStream) {
      res.write(chunk)
      const headUpdate = renderSSRHeadSuspenseChunk(head)
      if (headUpdate) {
        res.write(`<script>${headUpdate}</script>`)
      }
    }

    res.write(htmlEnd)
    res.end()
  }
}
```

## Caveats

::warning
- Create a new head instance per request to avoid state contamination
- Body-positioned scripts only appear in final output
- Requires client-side JavaScript for progressive updates
- Non-serializable values (functions, Promises) cannot be streamed
::

## API Reference

### createStreamableHead

```ts
// Client
import { createStreamableHead } from 'unhead/stream/client'

// Server
import { createStreamableHead } from 'unhead/stream/server'

// Server returns StreamableHeadContext
function createStreamableHead(options?: {
  streamKey?: string // default: '__unhead__'
  disableDefaults?: boolean
}): {
  head: Unhead
  onShellReady: () => void
  shellReady: Promise<void>
  wrapStream: (stream: ReadableStream, template: string) => ReadableStream
}
```

Creates a head instance optimized for streaming SSR.

| Option | Description |
|--------|-------------|
| `streamKey` | Window key for queue. Use different keys for multiple providers. |

| Return | Description |
|--------|-------------|
| `head` | The Unhead instance |
| `onShellReady` | Callback to signal shell is ready (for React's renderToPipeableStream) |
| `shellReady` | Promise that resolves when shell is ready |
| `wrapStream` | Wraps a ReadableStream to handle shell + template injection |

### renderSSRHeadShell

```ts
import { renderSSRHeadShell } from 'unhead/stream/server'

function renderSSRHeadShell(head: Unhead, template: string): Promise<string>
```

Renders initial shell with head tags and bootstrap script. Clears entries after rendering.

The function:
1. Renders current head entries to HTML
2. Injects a bootstrap script: `window.__unhead__ = { _q: [], push(e) { this._q.push(e) } }`{lang="ts"}
3. Clears all entries (they've been sent)

### renderSSRHeadSuspenseChunk

```ts
import { renderSSRHeadSuspenseChunk } from 'unhead/stream/server'

function renderSSRHeadSuspenseChunk(head: Unhead): string
```

Returns JS to push new head entries to client queue. Clears entries after rendering. Returns empty string if no new entries.

The returned string (when not empty) should be wrapped in a `<script>`{lang="html"} tag:

```ts
const update = renderSSRHeadSuspenseChunk(head)
if (update) {
  res.write(`<script>${update}</script>`)
}
```

### wrapStream

```ts
import { wrapStream } from 'unhead/stream/server'

function wrapStream(
  head: Unhead,
  stream: ReadableStream<Uint8Array>,
  template: string,
  placeholder?: string, // default: '<!--app-html-->'
  preRenderedState?: SSRHeadPayload
): ReadableStream<Uint8Array>
```

Convenience wrapper that handles shell rendering and template injection for Web ReadableStreams.

### prepareStreamingTemplate

```ts
import { prepareStreamingTemplate } from 'unhead/stream/server'

function prepareStreamingTemplate(
  head: Unhead,
  template: string,
  placeholder?: string // default: '<!--app-html-->'
): Promise<{
  shell: string
  end: string
}>
```

Splits template at placeholder and renders the shell with head tags. Returns the shell (before app content) and end (after app content) parts.
